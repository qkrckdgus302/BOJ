0x00오리엔테이션

0x01기초 코드 작성 요령1

0x02기초 코드 작성 요령2

0x03배열

1475번 idea가 안떠올라서 틀림 but 해설코드보고 이해함.
0x04리스트
1406번 거진 이해하고 90% 정답에 코드를 가깝게 구성했지만 
두가지부분에서 틀림
1) 입력이 B조건일때 예외처리를 적용하지 않았음.
2) cursor 위치를 end()-1로 생각함 문제 예시를 보면 end()가 맞음.
5397 1406 문제를 응용하면 풀 수 있음 99%다 맞았지만 백스페이스(-)을 사용하고나서 cursor 위치를 삭제된 위치 한칸뒤로 옮겨야 하는데
그걸 안했음....!
1158번 요세푸스 문제 내가 처음했던 풀이가 논리적으론 맞다고 생각하지만 어떤이유인지 모르는 에러가 발생 질문을 남겨놓은상태
해답풀이를 보았을때
1. 풀이는 list를 만들어서 활용하는건데 너무 복잡해보여서 pass
2. Queue(FIFO)을 쓰는 풀이로 가장간단하고 직관적이고 생각해볼만한 아이디어임(best)
3. vector를 쓰는 문제로 이문제로 일단 이해했는데 이문제의 아이디어는 이전에 풀어보지 않는이상 해당아이디어를 생각해내기 어려울것 같음.
여기까지는 그냥 다풀었음.

여기서부터는 바킹독이 시키는대로.

0x05스택

2493 앞에껄버려가는 아이디어를 생각했고 pair까지 써야겠다는 생각했지만 초기에 설정하는 알고리즘의 아이디어를 생각못했음.
결국 답지를 보았고 이해는 했으나 초기아이디어 없이는 못풀었을것같음.
▶ 이문제의 흐름을 잡는 가장큰 키포인트는 0번째 위치에 100,000,000벽이 있다고 생각하면 처음에 무조건 0이 출력되는 논리가 맞음

0x07덱

5430-AC 보기엔 간단하나 두가지 어려움이 있었다.
1-1, 입력을 단순히 숫자로 받는게아니고 [2,3,4,5]라는 형태로 받는상황이었다 string으로 입력받고 parse함수를 만들어서 숫자만 뽑아내어 덱 변수에 집어넣었다
1-2, 1-1에서 [2,324,4,5]라면 조금더 함수를 만드는게 어려워진다 답지를 보고 이해했지만 처음부터 만들라고 했다면 못만들었을것같다.
2, 이문제의 핵심은 최대한 Reverse를 적게써서 시간복잡도를 O(N)으로 만드는것이다 따라서 R을 적게쓰는 아이디어가 어려웠다. 이것도 답지보고 이해함
저녁 9시에 시작한문제라서 졸려서.. 답지 풀이보고 이해하고 넘어갔으나 굉장히 좋은 문제임에 틀림업다.

0X08 스택의 활용(수식의 괄호 쌍)

4949 틀린 이유중 가장큰 이유는 첫번째로 스택이 비어있는 상태에서 top()을 호출하면 런타임에러가 발생함
반복문을 돌때 스택을 초기화 해줘야하는데 스택을 반복문 바깥에 선언함..
3986
이문제같은경우 문제의 설명도 잘 이해가 안갔고 
예제입력2에서 AB,AAA가 좋은단어가 아닌지 너무헷갈려서 혼동을줌 AAA같은경우쌍을 지으면 삼지창모양으로 한점에서 교차하므로 X
AB같은경우는 쌍을짓기로 하였는데 쌍을 지을수없으므로 X 
AA는 선끼리 교차하지 않고 다른취이에 있는 같은글자와 짝을 지을수 있으므로 O
9012(4949, 3986번을 응용해서 해결하였음.)
10799,2504 일단 pass후 시간남을때 풀기로함.

0X09 BFS
1926번 BFS TEMPLETE코드를 이해한뒤 그코드를 그대로 응용해서 문제를 해결하였음 강사님 코드랑 약간 차이는 있으나 해결방법에 대한 아이디어는 똑같으므로 맞았다고 생각함.
2178 두가지 실수를 해서 틀렸다
첫번째, 2차원 배열을 입력받을때 띄워쓰기를 하지 않는다고 했기때문에 각배열을 string으로 입력받아야 했어야 했지만,
하지만 이부분을 간과하고 숫자를 하나씩 공백을 가지고 입력을 받는 실수를 하였다.
두번째, 이차원 배열 dist를 -1로 초기화하라고 했었는데 이부분에서 int dist[102][102] = {-1}로 초기화를 했다 이렇게하면 0,0만 -1이되고 나머지는 0으로 초기화 된다.
문법을 틀리게 알고 있었다. 이부분은 for (int i = 0; i < n; i++) fill(dist[i], dist[i] + m, -1); 이렇게 초기화 하는게 맞다.
7576 토마토 문제 처음에 접근한 방식으로 해결방법이 안 보여서 풀이를 참고했다 결국은 익은 토마토지점으로부터 거리를 구하는 bfs알고리즘을 활용하면된다는것을 
완벽하게 이해했다.
4179 불 
두가지 포인트를 놓쳐서 틀렸다 
1. if (nx < 0 || nx >= R || ny < 0 || ny >= C)
            {
               cout << jihun[cur.X][cur.Y] + 1;
               return 0;
            }
1번 부분을 continue로 두고 뒤쪽에서 지훈 값중 가장 큰값 +1로 구했는데 그렇게 구하면 지훈이가 제일 빨리가는 루트가 아니라 오래걸리는 루트가 나올 수 있기 때문에 정답이아니다.
bfs의 가장 중요한 원리는 스택에 쌓이는 거리 값들이 오름차순으로 쌓인다 따라서 가장자리에 도착한 상태에서 문바깥쪽을 처음으로 탐색한 그위치가 가장 빠른 값이다. 그렇기 때문에 위의 코드로 작성하는게 알맞다.
2.if (fire[nx][ny] != -1 && fire[nx][ny] <= jihun[cur.X][cur.Y] + 1) continue;
fire[nx][ny] != -1 이 부분이 왜 필요한지 아햐거 안갔으나 아래예시를 통해 이해함 fire가 -1인경우는 벽으로막혀있는공간 이외에도 불꽃이 퍼지지 못한공간도 포함됨.

만약 불꽃이 퍼지지 못한공간을 지훈이가 지나갈 수 있다고 가정했을때 -1 < 양수 조건이되면서 지훈이가 지나가야하지만 못하는 조건이 될 수 있기 때문에
fire가 -1이 아닐때 조건을 추가해 줘야함.

###F
.J#.
###.
-1 -1 -1 0
-1 -1 -1 1
-1 -1 -1 2

-1 -1 -1 -1
-1 0 -1 -1
-1 -1 -1 -1
1697 숨박꼭질
일차원 BFS에 대한 내용이다. 크게 어려운점도 없었고 결과적으로 해결하였으나, 
초기에 수빈이의 위치값을 큐에는 넣었으나. 거리값을 가진 dist배열에 넣지 않아서 예시와 일치하지 않는 문제가 있었다.
dist값을 모두 -1로 초기화 했기때문에 시작위치에 반드시 0을 넣어 주어야한다.
Q.push(N);
dist[N] = 0; // 이 부분을 추가하여 문제를 해결하였다.
1012 유기농 배추 
맞았다고 생각했는데 계속 틀렸다 그이유는
if (board[nx][ny] != 1 || vis[nx][ny]) 조건문에서 앤드조건을 

100026 적록색약 해결하였음
7569 토마토 내풀이법, 바킹독 풀이법 둘다 이해하였으나, 내풀이법으로 풀때는 34, 35 ,36의 위치를 다른데 넣어서 틀린걸 해결하였음.
  if (board[k][i][j] == -1)
  {
       vist[k][i][j] = 1;
  }
7562 나이트의 이동 해결하였음.
5427 불 맨마지막 지훈이에 대한 큐의 처리 과정에서
지훈이가 탈출할때 break;처리후 while문에대한 break도 처리 했어야 했는데 그렇지 못했음. 결국 지훈이 탈출시 
for문탈출 while문 탈출 둘다 진행하여 문제를 해결하였음.


2583 영역구하기
if(nx < 0 || nx >= m || ny < 0 || ny >= n) continue; 
부분에서 m과 n을 반대로 넣어서 풀지못했고 4시간동안 오류를 찾지 못했다..후... 
그렇게 어려운문제가 아니다..
        
        if(dist[i][j] >= 0) continue;
            Q.push({i,j});
            dist[i][j] = 1;
            width=1;
            cnt++;
 이부분을  continue로 처리하지않고 만약 아래와 같은 형태로 처리하면 이중포문을 모두돌면서 ans.push_back(width);
 발생하기 때문에 이중포문의 n*m 갯수만큼 vector가 쌓이게되고 이를 출력하기가 애매해진다..
  
        if(dist[i][j] == -1)
        {
            Q.push({i,j});
            dist[i][j] = 1;
            width=1;
            cnt++;
            }      
2667: 단지번호붙이기
쉽게 해결하였음.
            




2206 벽 부수고 이동하기
여차저차 생각의 순서대로 답은 구했으나 시간초과가 뜸..!
해답 풀이를 보고 대략적으로 이해하였으나 이런 방식으로 아이디어를 떠오르는부분이 어렵다고 생각하였음.
응용문제가 어렵다고 판단하고 다시 연습문제로 넘어가기로함.            
            
            
            

0X0A DFS
BFS문제랑 같음.

0X0B 재귀
1629 곱셈
풀이를 참고하여 이해하였다.
modulo연산의 속성에 대한 정의를 알고 있어야지 풀 수 있는문제.
(a%n * b%n)%n = (a*b)%n
((a^k)%n * (a^k)%n)%n = a^2k % n
11729 하노이 탑
한 번 풀었던 문제임에도 귀납적인 사고가 너무 어려웠고, 풀이를 참고하였다.
1074 Z
마찬가지로 풀이를 참고하였다. 재귀자체가 해답을 보았을땐 이해가 되지만 귀납적으로 생각하여 코드를 구성하는 과정이 너무 어려웠다.
1.함수의정의
2.base condition
3.재귀 식
이 순서를 지켜서 작성해보아야겠다.. 너무 어렵다..



