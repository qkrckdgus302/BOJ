1018 체스판 다시칠하기
틀린이유
1. 너무 어렵게 생각했으나 사실 bw, wb 즉 조건을 만족하는 8x8 체스판을 만들어놓은 상태에서 비교하기만했으면 되는문제
2. 왼쪽위칸에서 시작할때 그값이 W면 당연히 WB, B면 BW 체스판으로 바꾸어야한다고 생각했으나 그렇지 않은경우가 있음
EX) 3, 3 WB체스판을 선택할경우 4개 변경 BW체스판을 선택할경우 5개
BBB 
BBB 
BBW
10816: 숫자 카드2

해쉬테이블을 이용한 풀이
unordered_map <int,int> map;

이분 탐색을 이용한 풀이는 Algorithm STL의 upper_bound, lower_bound을 사용한 풀이가 있었다.
이분 탐색을 위해서 오름차순 정렬을 해주고, upper_bound와 lower_bound을 이용해서 결과를 출력했다.
 - upper_bound : 찾고자 하는 값의 다음 값이 최초로 나타나는 위치
 - lower_bound : 찾고자 하는 값 이상이 처음 나타나는 위치

 

즉, 1 2 4 4 6 7에서
lower_bound(~,~,4)의 결과 : 3 (4 이상의 값이 처음 나타나는 위치)
upper_bound(~,~,4)의 결과 : 5 (4를 초과하는 값이 처음 나타나는 위치)를 이용해서 
사이의 값을 빼주면 2가 나오고 이것은 결국 저장된 4의 개수가 된다.

11866 요세푸스 문제 0
q를 이용하면 간단한문제임. 
아이디어가 안떠올랐으나 문제유형에 q가 있는것을 보고 파악하여 해결함.


1436번 영화감독 숍
풀긴 풀었으나 다른 문제 풀이방법을 보고 가장 쉽게푸는방법은
받은 숫자를 to_string method를 활용하여 문자열로 변경하여 6 6 6이 연속으로 세번등장하는지 체크하고 만약에 연속으로 3번등장했다면 break문으로
for문으로 탈출하는 방법이 가장 간단하다는 생각이 들었다.
https://cryptosalamander.tistory.com/43


15829 Hashing

(a+b) % Mod = (a%Mod + a%Mod) % Mod 같은 원리를 이용하는것


1874 스택수열
틀린이유
1.vector를 사용하여 문자를 집어넣고 나중에 출력하는 아이디어에 대해서 생각하지 못했음.
2.if , else if, else 조건을 잘못생각함. else if s.top==num 조건과 else케이스가 필요하다는 부분을 생각하지 못했음.

2805 나무자르기

틀린이유
1.이분탐색이라고 생각하지 못했음. but M크기 2,000,000,000이므로 단순히 for으로 탐색하면 1억번 연산을 넘게해서 1초 초과가 발생함.
2.이분탐색을 파악했을때 틀린이유 실제로 가져가려는 나무의 길이 m을 가져갈수 있는 상황도 있지만 그렇지 않은경우 m보다 조금 더 가져가야하는 상황이 발생할 수 있는 그 경우를
고려하지 않았음.
	else if(sum > m)
		{
			result = mid; // 이부분이 반드시 필요함.
			st = mid + 1;
		}
		else
		{
			result = mid;
			cout << mid << '\n';
			return 0;
		}
		
18111 마인크래프트
틀린이유
1. 시간초과가 발생했는데 틀린이유는 브루트포스라고 해도 너무 복잡하게 생각한것같다.
2. 해답풀이와 내 풀이의 가장 큰 차이는 내 풀이 같은경우 너무 많은 변수들을 설정하고 사용하려고 한 반면
정답풀이 같은경우는 수학적으로 접근하여 굳이 필요없는 자료형을 생성해서 사용하지 않았다.
가장 큰아이디어의 차이는 int leastTime = 1e9; 변수인것같고, 그다음은 h=0부터 h=256까지 모두 h에대한 땅고르기가 가능한지 판단하고, 땅고르기가 가능하면 시간을 구해서 최소시간인지 확인하고
최소시간이 같은경우 높이가 더높은 값을 찾아가는 과정을 수행한다는점인것같다.

1676: 팩토리얼 0의 개수
1. 약수가 10을 포함하는 갯수만큼 0의 갯수가 증가하는것은 이해하였으나. 2*5에서 2의개수가 어차피 압도적으로많으므로
5의 개수만 계산하면 된다는것을 생각하지못했고.
2. 인터넷에 나온 정석적인 풀이를 이해하지 못해서 내가 이해한 풀이로 해결하였다.

1463: 1로 만들기
1. 어떻게 구현할지 잘 감히 오지 않았다.
2. BFS로 풀 수 있다는것을 발견하여 BFS 풀이로 우선 해결하였다.
3. dp로 풀어야한다는것을 알았는데도 감이오질 않아서 바킹독 강의를 보았다.
dp 여러개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘
1.테이블정의하기
d[i] =i;
2.점화식찾기
d[12]=?
3.초기값 정의하기
d[1]=0

